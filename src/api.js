// @flow
/* eslint-disable no-use-before-define */
/**
 * Messente API
 * [Messente](https://messente.com) is a global provider of messaging and user verification services. Use Messente API library to send and receive SMS, Viber and WhatsApp messages, blacklist phone numbers to make sure you're not sending any unwanted messages, manage contacts and groups.  Messente builds [tools](https://messente.com/documentation) to help organizations connect their services to people anywhere in the world.
 *
 * OpenAPI spec version: 0.0.1
 * Contact: messente@messente.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.messente.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}


/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Defines the delivery channel
 * @export
 * @enum {string}
 */
export type Channel = 'sms' | 'viber' | 'whatsapp';

/**
 * 
 * @export
 */
export type ContactEnvelope = {
    /**
     * 
     * @type {ContactFields}
     * @memberof ContactEnvelope
     */
    contact?: ContactFields;
}


/**
 * 
 * @export
 */
export type ContactFields = {
    /**
     * Phone number in e.164 format
     * @type {string}
     * @memberof ContactFields
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    custom?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    custom2?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    custom3?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactFields
     */
    custom4?: string;
}


/**
 * 
 * @export
 */
export type ContactListEnvelope = {
    /**
     * 
     * @type {Array<ContactFields>}
     * @memberof ContactListEnvelope
     */
    contacts?: Array<ContactFields>;
}


/**
 * 
 * @export
 */
export type ContactUpdateFields = {
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    custom?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    custom2?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    custom3?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactUpdateFields
     */
    custom4?: string;
}


/**
 * 
 * @export
 */
export type DeliveryReportResponse = {
    /**
     * Contains the delivery reports for each channnel, ordered by send order
     * @type {Array<DeliveryResult>}
     * @memberof DeliveryReportResponse
     */
    statuses: Array<DeliveryResult>;
    /**
     * Phone number in e.164 format
     * @type {string}
     * @memberof DeliveryReportResponse
     */
    to: string;
    /**
     * Unique identifier for the Omnimessage
     * @type {string}
     * @memberof DeliveryReportResponse
     */
    omnimessageId: string;
}


/**
 * 
 * @export
 */
export type DeliveryResult = {
    /**
     * 
     * @type {Status}
     * @memberof DeliveryResult
     */
    status?: Status;
    /**
     * 
     * @type {Channel}
     * @memberof DeliveryResult
     */
    channel?: Channel;
    /**
     * Unique identifier for the message
     * @type {string}
     * @memberof DeliveryResult
     */
    messageId?: string;
    /**
     * Human-readable description of what went wrong, *null* in case of success or if the messages has not been processed yet
     * @type {string}
     * @memberof DeliveryResult
     */
    error?: string;
    /**
     * 
     * @type {ErrorCodeOmnichannelMachine}
     * @memberof DeliveryResult
     */
    err?: ErrorCodeOmnichannelMachine;
    /**
     * When this status was received by Omnichannel API
     * @type {Date}
     * @memberof DeliveryResult
     */
    timestamp?: Date;
}


/**
 * 
 * @export
 */
export type EmptyObject = {
}


/**
 * Matches the following ErrorTitleOmnichannel.   This field is a constant.    * 101 - Not found   * 102 - Forbidden   * 103 - Unauthorized   * 104 - Invalid data   * 105 - Internal Server Error   * 106 - Missing data   * 107 - Method not allowed
 * @export
 * @enum {string}
 */
export type ErrorCodeOmnichannel = '101' | '102' | '103' | '104' | '105' | '106' | '107';

/**
 * Machine-readable error code, 'null' when the message has not been processed yet    * 0 - No error   * 1 - Delivery failure   * 2 - Sending message expired   * 3 - Invalid number   * 4 - Error crediting account   * 5 - Invalid number format   * 6 - Too many identical messages   * 7 - Sender name not allowed   * 8 - Operator blacklisted   * 9 - Unroutable   * 10 - Seen   * 999 - General temporary error
 * @export
 * @enum {string}
 */
export type ErrorCodeOmnichannelMachine = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 999;

/**
 * Matches the following ErrorTitlePhonebook.   This field is a constant.    * 201 - Invalid data   * 202 - Unauthorized   * 203 - Missing resource   * 204 - Conflict   * 244 - Client error   * 205 - General error
 * @export
 * @enum {string}
 */
export type ErrorCodePhonebook = '201' | '202' | '203' | '204' | '244' | '205';

/**
 * 
 * @export
 */
export type ErrorItemOmnichannel = {
    /**
     * 
     * @type {ErrorTitleOmnichannel}
     * @memberof ErrorItemOmnichannel
     */
    title: ErrorTitleOmnichannel;
    /**
     * Free form more detailed description of the error.
     * @type {string}
     * @memberof ErrorItemOmnichannel
     */
    detail: string;
    /**
     * 
     * @type {ErrorCodeOmnichannel}
     * @memberof ErrorItemOmnichannel
     */
    code: ErrorCodeOmnichannel;
    /**
     * Describes which field is causing the issue in the payload, null for non 400 status code responses
     * @type {string}
     * @memberof ErrorItemOmnichannel
     */
    source: string;
}


/**
 * 
 * @export
 */
export type ErrorItemPhonebook = {
    /**
     * 
     * @type {ErrorTitlePhonebook}
     * @memberof ErrorItemPhonebook
     */
    title: ErrorTitlePhonebook;
    /**
     * Free form more detailed description of the error.
     * @type {string}
     * @memberof ErrorItemPhonebook
     */
    detail: string;
    /**
     * 
     * @type {ErrorCodePhonebook}
     * @memberof ErrorItemPhonebook
     */
    code: ErrorCodePhonebook;
}


/**
 * 
 * @export
 */
export type ErrorOmnichannel = {
    /**
     * 
     * @type {Array<ErrorItemOmnichannel>}
     * @memberof ErrorOmnichannel
     */
    errors: Array<ErrorItemOmnichannel>;
}


/**
 * 
 * @export
 */
export type ErrorPhonebook = {
    /**
     * 
     * @type {Array<ErrorItemPhonebook>}
     * @memberof ErrorPhonebook
     */
    errors: Array<ErrorItemPhonebook>;
}


/**
 * Textual value which corresponds to ErrorCodeOmnichannel
 * @export
 * @enum {string}
 */
export type ErrorTitleOmnichannel = 'Not found' | 'Forbidden' | 'Unauthorized' | 'Invalid data' | 'Internal Server Error' | 'Missing data' | 'Method not allowed';

/**
 * Textual value which corresponds to ErrorCodePhonebook
 * @export
 * @enum {string}
 */
export type ErrorTitlePhonebook = 'Invalid data' | 'Unauthorized' | 'Missing resource' | 'Conflict' | 'Client error' | 'General error';

/**
 * 
 * @export
 */
export type FetchBlacklistSuccess = {
    /**
     * 
     * @type {Array<string>}
     * @memberof FetchBlacklistSuccess
     */
    phoneNumbers?: Array<string>;
}


/**
 * 
 * @export
 */
export type GroupEnvelope = {
    /**
     * 
     * @type {GroupResponseFields}
     * @memberof GroupEnvelope
     */
    group?: GroupResponseFields;
}


/**
 * 
 * @export
 */
export type GroupListEnvelope = {
    /**
     * 
     * @type {Array<GroupResponseFields>}
     * @memberof GroupListEnvelope
     */
    groups?: Array<GroupResponseFields>;
}


/**
 * 
 * @export
 */
export type GroupName = {
    /**
     * 
     * @type {string}
     * @memberof GroupName
     */
    name: string;
}


/**
 * 
 * @export
 */
export type GroupResponseFields = {
    /**
     * Id string in uuid format
     * @type {string}
     * @memberof GroupResponseFields
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponseFields
     */
    name: string;
    /**
     * format %Y-%m-%dT%H:%M:%S.%fZ
     * @type {string}
     * @memberof GroupResponseFields
     */
    createdOn?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupResponseFields
     */
    contactsCount: number;
}


/**
 * 
 * @export
 */
export type MessageResult = {
    /**
     * Unique identifier for the message
     * @type {string}
     * @memberof MessageResult
     */
    messageId: string;
    /**
     * 
     * @type {Channel}
     * @memberof MessageResult
     */
    channel: Channel;
    /**
     * Sender that was used for the message
     * @type {string}
     * @memberof MessageResult
     */
    sender: string;
}


/**
 * 
 * @export
 */
export type NumberToBlacklist = {
    /**
     * Phone number in e.164 format
     * @type {string}
     * @memberof NumberToBlacklist
     */
    phoneNumber: string;
}


/**
 * 
 * @export
 */
export type OmniMessageCreateSuccessResponse = {
    /**
     * List of messages that compose the Omnimessage
     * @type {Array<MessageResult>}
     * @memberof OmniMessageCreateSuccessResponse
     */
    messages: Array<MessageResult>;
    /**
     * Phone number in e.164 format
     * @type {string}
     * @memberof OmniMessageCreateSuccessResponse
     */
    to: string;
    /**
     * Unique identifier for the Omnimessage
     * @type {string}
     * @memberof OmniMessageCreateSuccessResponse
     */
    omnimessageId: string;
}


/**
 * 
 * @export
 */
export type Omnimessage = {
    /**
     * Phone number in e.164 format
     * @type {string}
     * @memberof Omnimessage
     */
    to: string;
    /**
     * 
     * @type {Array<Object>}
     * @memberof Omnimessage
     */
    messages: Array<Object>;
    /**
     * URL where the delivery report will be sent
     * @type {string}
     * @memberof Omnimessage
     */
    dlrUrl?: string;
    /**
     * Optional parameter for sending messages at some specific time in the future.   Time must be specified in the 8601 format.   If no timezone is specified, then the timezone is assumed to be UTC.    Examples:    * Time specified with timezone: 2018-06-22T09:05:07+00:00 Time specified in UTC: 2018-06-22T09:05:07Z   * Time specified without timezone: 2018-06-22T09:05 (equivalent to 2018-06-22T09:05+00:00)
     * @type {Date}
     * @memberof Omnimessage
     */
    timeToSend?: Date;
}



            export type SMSAutoconvertEnum = 'full' | 'on' | 'off';

            export type SMSChannelEnum = 'sms';
/**
 * SMS message content
 * @export
 */
export type SMS = {
    /**
     * Text content of the SMS
     * @type {string}
     * @memberof SMS
     */
    text: string;
    /**
     * Phone number or alphanumeric sender name
     * @type {string}
     * @memberof SMS
     */
    sender?: string;
    /**
     * After how many minutes this channel is considered as failed and the next channel is attempted
     * @type {number}
     * @memberof SMS
     */
    validity?: number;
    /**
     * Defines how non-GSM characters will be treated:    - \"on\" Use replacement settings from the account's [API Auto Replace settings page](https://dashboard.messente.com/api-settings/auto-replace)(default)   - \"full\" All non GSM 03.38 characters will be replaced with suitable alternatives   - \"off\" Message content is not modified in any way
     * @type {string}
     * @memberof SMS
     */
    autoconvert?: SMSAutoconvertEnum;
    /**
     * hex-encoded string containing SMS UDH
     * @type {string}
     * @memberof SMS
     */
    udh?: string;
    /**
     * 
     * @type {string}
     * @memberof SMS
     */
    channel?: SMSChannelEnum;
}


/**
 * The human-readable equivalent for this field is contained in \"error\".   This value is *null* if the message is still being processed.
 * @export
 * @enum {string}
 */
export type Status = 'ACK' | 'DELIVRD' | 'UNDELIV' | 'FAILED' | 'UNKNOWN' | 'ACCEPTD' | 'REJECTD' | 'DELETED' | 'EXPIRED' | 'NACK' | 'SEEN';


            export type ViberChannelEnum = 'viber';
/**
 * Viber message content
 * @export
 */
export type Viber = {
    /**
     * Phone number or alphanumeric sender name
     * @type {string}
     * @memberof Viber
     */
    sender?: string;
    /**
     * After how many minutes this channel is considered as failed and the next channel is attempted
     * @type {number}
     * @memberof Viber
     */
    validity?: number;
    /**
     * Plaintext content for Viber
     * @type {string}
     * @memberof Viber
     */
    text?: string;
    /**
     * URL for the embedded image.    Valid combinations:    1) image_url,    2) text, image_url, button_url, button_text
     * @type {string}
     * @memberof Viber
     */
    imageUrl?: string;
    /**
     * URL of the button, must be specified along with ''text'', ''button_text'' and ''image_url'' (optional)
     * @type {string}
     * @memberof Viber
     */
    buttonUrl?: string;
    /**
     * Must be specified along with ''text'', ''button_url'', ''button_text'', ''image_url'' (optional)
     * @type {string}
     * @memberof Viber
     */
    buttonText?: string;
    /**
     * 
     * @type {string}
     * @memberof Viber
     */
    channel?: ViberChannelEnum;
}



            export type WhatsAppChannelEnum = 'whatsapp';
/**
 * WhatsApp message content.   Only one of \"text\", \"image\", \"document\" or \"audio\" can be provided.
 * @export
 */
export type WhatsApp = {
    /**
     * Phone number or alphanumeric sender name
     * @type {string}
     * @memberof WhatsApp
     */
    sender?: string;
    /**
     * After how many minutes this channel is   considered as failed and the next channel is attempted
     * @type {number}
     * @memberof WhatsApp
     */
    validity?: number;
    /**
     * 
     * @type {WhatsAppText}
     * @memberof WhatsApp
     */
    text?: WhatsAppText;
    /**
     * 
     * @type {WhatsAppImage}
     * @memberof WhatsApp
     */
    image?: WhatsAppImage;
    /**
     * 
     * @type {WhatsAppDocument}
     * @memberof WhatsApp
     */
    document?: WhatsAppDocument;
    /**
     * 
     * @type {WhatsAppAudio}
     * @memberof WhatsApp
     */
    audio?: WhatsAppAudio;
    /**
     * 
     * @type {string}
     * @memberof WhatsApp
     */
    channel?: WhatsAppChannelEnum;
}


/**
 * 
 * @export
 */
export type WhatsAppAudio = {
    /**
     * Base64-encoded audio
     * @type {string}
     * @memberof WhatsAppAudio
     */
    content: string;
}


/**
 * 
 * @export
 */
export type WhatsAppDocument = {
    /**
     * Description for the document
     * @type {string}
     * @memberof WhatsAppDocument
     */
    caption?: string;
    /**
     * Base64-encoded image
     * @type {string}
     * @memberof WhatsAppDocument
     */
    content: string;
}


/**
 * 
 * @export
 */
export type WhatsAppImage = {
    /**
     * Description for the image
     * @type {string}
     * @memberof WhatsAppImage
     */
    caption?: string;
    /**
     * Base64-encoded image
     * @type {string}
     * @memberof WhatsAppImage
     */
    content: string;
}


/**
 * 
 * @export
 */
export type WhatsAppText = {
    /**
     * Whether to display link preview if the message contains a hyperlink.
     * @type {boolean}
     * @memberof WhatsAppText
     */
    previewUrl?: boolean;
    /**
     * Plaintext content for WhatsApp, can contain URLs, emojis and formatting
     * @type {string}
     * @memberof WhatsAppText
     */
    body: string;
}




/**
 * BlacklistApi - fetch parameter creator
 * @export
 */
export const BlacklistApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a phone number to the blacklist.
         * @throws {RequiredError}
         */
        addToBlacklist(numberToBlacklist: NumberToBlacklist, options: RequestOptions): FetchArgs {
            // verify required parameter 'numberToBlacklist' is not null or undefined
            if (numberToBlacklist === null || numberToBlacklist === undefined) {
                throw new RequiredError('numberToBlacklist','Required parameter numberToBlacklist was null or undefined when calling addToBlacklist.');
            }
            const localVarPath = `/phonebook/blacklist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof numberToBlacklist !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(numberToBlacklist || {}) : (((numberToBlacklist:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a phone number from the blacklist.
         * @throws {RequiredError}
         */
        deleteFromBlacklist(phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling deleteFromBlacklist.');
            }
            const localVarPath = `/blacklist/{phone}`
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all blacklisted phone numbers.
         * @throws {RequiredError}
         */
        fetchBlacklist(options: RequestOptions): FetchArgs {
            const localVarPath = `/phonebook/blacklist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if a phone number is blacklisted.
         * @throws {RequiredError}
         */
        isBlacklisted(phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling isBlacklisted.');
            }
            const localVarPath = `/blacklist/{phone}`
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BlacklistApiType = { 
    addToBlacklist(numberToBlacklist: NumberToBlacklist, options?: RequestOptions): Promise<Response>,

    deleteFromBlacklist(phone: string, options?: RequestOptions): Promise<Response>,

    fetchBlacklist(options?: RequestOptions): Promise<FetchBlacklistSuccess>,

    isBlacklisted(phone: string, options?: RequestOptions): Promise<Response>,
}

/**
 * BlacklistApi - factory function to inject configuration 
 * @export
 */
export const BlacklistApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BlacklistApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Adds a phone number to the blacklist.
         * @throws {RequiredError}
         */
        addToBlacklist(numberToBlacklist: NumberToBlacklist, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = BlacklistApiFetchParamCreator(configuration).addToBlacklist(numberToBlacklist, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes a phone number from the blacklist.
         * @throws {RequiredError}
         */
        deleteFromBlacklist(phone: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = BlacklistApiFetchParamCreator(configuration).deleteFromBlacklist(phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns all blacklisted phone numbers.
         * @throws {RequiredError}
         */
        fetchBlacklist(options?: RequestOptions = {}): Promise<FetchBlacklistSuccess> {
            const localVarFetchArgs = BlacklistApiFetchParamCreator(configuration).fetchBlacklist(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Checks if a phone number is blacklisted.
         * @throws {RequiredError}
         */
        isBlacklisted(phone: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = BlacklistApiFetchParamCreator(configuration).isBlacklisted(phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * ContactsApi - fetch parameter creator
 * @export
 */
export const ContactsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a contact to a group.
         * @throws {RequiredError}
         */
        addContactToGroup(groupId: string, phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling addContactToGroup.');
            }
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling addContactToGroup.');
            }
            const localVarPath = `/groups/{groupId}/contacts/{phone}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new contact.
         * @throws {RequiredError}
         */
        createContact(contactFields: ContactFields, options: RequestOptions): FetchArgs {
            // verify required parameter 'contactFields' is not null or undefined
            if (contactFields === null || contactFields === undefined) {
                throw new RequiredError('contactFields','Required parameter contactFields was null or undefined when calling createContact.');
            }
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof contactFields !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(contactFields || {}) : (((contactFields:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a contact.
         * @throws {RequiredError}
         */
        deleteContact(phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling deleteContact.');
            }
            const localVarPath = `/contacts/{phone}`
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists a contact.
         * @throws {RequiredError}
         */
        fetchContact(phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling fetchContact.');
            }
            const localVarPath = `/contacts/{phone}`
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists groups of a contact.
         * @throws {RequiredError}
         */
        fetchContactGroups(phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling fetchContactGroups.');
            }
            const localVarPath = `/contacts/{phone}/groups`
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all contacts.
         * @throws {RequiredError}
         */
        fetchContacts(groupIds?: Array<string>, options: RequestOptions): FetchArgs {
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (groupIds) {
                localVarQueryParameter['groupIds'] = groupIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a contact from a group.
         * @throws {RequiredError}
         */
        removeContactFromGroup(groupId: string, phone: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling removeContactFromGroup.');
            }
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling removeContactFromGroup.');
            }
            const localVarPath = `/groups/{groupId}/contacts/{phone}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a contact.
         * @throws {RequiredError}
         */
        updateContact(phone: string, contactUpdateFields: ContactUpdateFields, options: RequestOptions): FetchArgs {
            // verify required parameter 'phone' is not null or undefined
            if (phone === null || phone === undefined) {
                throw new RequiredError('phone','Required parameter phone was null or undefined when calling updateContact.');
            }
            // verify required parameter 'contactUpdateFields' is not null or undefined
            if (contactUpdateFields === null || contactUpdateFields === undefined) {
                throw new RequiredError('contactUpdateFields','Required parameter contactUpdateFields was null or undefined when calling updateContact.');
            }
            const localVarPath = `/contacts/{phone}`
                .replace(`{${"phone"}}`, encodeURIComponent(String(phone)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof contactUpdateFields !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(contactUpdateFields || {}) : (((contactUpdateFields:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ContactsApiType = { 
    addContactToGroup(groupId: string, phone: string, options?: RequestOptions): Promise<EmptyObject>,

    createContact(contactFields: ContactFields, options?: RequestOptions): Promise<ContactEnvelope>,

    deleteContact(phone: string, options?: RequestOptions): Promise<Response>,

    fetchContact(phone: string, options?: RequestOptions): Promise<ContactEnvelope>,

    fetchContactGroups(phone: string, options?: RequestOptions): Promise<GroupListEnvelope>,

    fetchContacts(groupIds?: Array<string>, options?: RequestOptions): Promise<ContactListEnvelope>,

    removeContactFromGroup(groupId: string, phone: string, options?: RequestOptions): Promise<Response>,

    updateContact(phone: string, contactUpdateFields: ContactUpdateFields, options?: RequestOptions): Promise<ContactEnvelope>,
}

/**
 * ContactsApi - factory function to inject configuration 
 * @export
 */
export const ContactsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ContactsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Adds a contact to a group.
         * @throws {RequiredError}
         */
        addContactToGroup(groupId: string, phone: string, options?: RequestOptions = {}): Promise<EmptyObject> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).addContactToGroup(groupId, phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates a new contact.
         * @throws {RequiredError}
         */
        createContact(contactFields: ContactFields, options?: RequestOptions = {}): Promise<ContactEnvelope> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).createContact(contactFields, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes a contact.
         * @throws {RequiredError}
         */
        deleteContact(phone: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).deleteContact(phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Lists a contact.
         * @throws {RequiredError}
         */
        fetchContact(phone: string, options?: RequestOptions = {}): Promise<ContactEnvelope> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).fetchContact(phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Lists groups of a contact.
         * @throws {RequiredError}
         */
        fetchContactGroups(phone: string, options?: RequestOptions = {}): Promise<GroupListEnvelope> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).fetchContactGroups(phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns all contacts.
         * @throws {RequiredError}
         */
        fetchContacts(groupIds?: Array<string>, options?: RequestOptions = {}): Promise<ContactListEnvelope> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).fetchContacts(groupIds, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Removes a contact from a group.
         * @throws {RequiredError}
         */
        removeContactFromGroup(groupId: string, phone: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).removeContactFromGroup(groupId, phone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Updates a contact.
         * @throws {RequiredError}
         */
        updateContact(phone: string, contactUpdateFields: ContactUpdateFields, options?: RequestOptions = {}): Promise<ContactEnvelope> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).updateContact(phone, contactUpdateFields, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * DeliveryReportApi - fetch parameter creator
 * @export
 */
export const DeliveryReportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves the delivery report for the Omnimessage.
         * @throws {RequiredError}
         */
        retrieveDeliveryReport(omnimessageId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'omnimessageId' is not null or undefined
            if (omnimessageId === null || omnimessageId === undefined) {
                throw new RequiredError('omnimessageId','Required parameter omnimessageId was null or undefined when calling retrieveDeliveryReport.');
            }
            const localVarPath = `/omnimessage/{omnimessageId}/status`
                .replace(`{${"omnimessageId"}}`, encodeURIComponent(String(omnimessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DeliveryReportApiType = { 
    retrieveDeliveryReport(omnimessageId: string, options?: RequestOptions): Promise<DeliveryReportResponse>,
}

/**
 * DeliveryReportApi - factory function to inject configuration 
 * @export
 */
export const DeliveryReportApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DeliveryReportApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Retrieves the delivery report for the Omnimessage.
         * @throws {RequiredError}
         */
        retrieveDeliveryReport(omnimessageId: string, options?: RequestOptions = {}): Promise<DeliveryReportResponse> {
            const localVarFetchArgs = DeliveryReportApiFetchParamCreator(configuration).retrieveDeliveryReport(omnimessageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * GroupsApi - fetch parameter creator
 * @export
 */
export const GroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new group with the provided name.
         * @throws {RequiredError}
         */
        createGroup(groupName: GroupName, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupName' is not null or undefined
            if (groupName === null || groupName === undefined) {
                throw new RequiredError('groupName','Required parameter groupName was null or undefined when calling createGroup.');
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof groupName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(groupName || {}) : (((groupName:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a group.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists a group.
         * @throws {RequiredError}
         */
        fetchGroup(groupId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling fetchGroup.');
            }
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all groups.
         * @throws {RequiredError}
         */
        fetchGroups(options: RequestOptions): FetchArgs {
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a group with the provided name.
         * @throws {RequiredError}
         */
        updateGroup(groupId: string, groupName: GroupName, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'groupName' is not null or undefined
            if (groupName === null || groupName === undefined) {
                throw new RequiredError('groupName','Required parameter groupName was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof groupName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(groupName || {}) : (((groupName:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type GroupsApiType = { 
    createGroup(groupName: GroupName, options?: RequestOptions): Promise<GroupEnvelope>,

    deleteGroup(groupId: string, options?: RequestOptions): Promise<Response>,

    fetchGroup(groupId: string, options?: RequestOptions): Promise<GroupEnvelope>,

    fetchGroups(options?: RequestOptions): Promise<GroupListEnvelope>,

    updateGroup(groupId: string, groupName: GroupName, options?: RequestOptions): Promise<GroupEnvelope>,
}

/**
 * GroupsApi - factory function to inject configuration 
 * @export
 */
export const GroupsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): GroupsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates a new group with the provided name.
         * @throws {RequiredError}
         */
        createGroup(groupName: GroupName, options?: RequestOptions = {}): Promise<GroupEnvelope> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).createGroup(groupName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes a group.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).deleteGroup(groupId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Lists a group.
         * @throws {RequiredError}
         */
        fetchGroup(groupId: string, options?: RequestOptions = {}): Promise<GroupEnvelope> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).fetchGroup(groupId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns all groups.
         * @throws {RequiredError}
         */
        fetchGroups(options?: RequestOptions = {}): Promise<GroupListEnvelope> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).fetchGroups(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Updates a group with the provided name.
         * @throws {RequiredError}
         */
        updateGroup(groupId: string, groupName: GroupName, options?: RequestOptions = {}): Promise<GroupEnvelope> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).updateGroup(groupId, groupName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

/**
 * OmnimessageApi - fetch parameter creator
 * @export
 */
export const OmnimessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a scheduled Omnimessage.
         * @throws {RequiredError}
         */
        cancelScheduledMessage(omnimessageId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'omnimessageId' is not null or undefined
            if (omnimessageId === null || omnimessageId === undefined) {
                throw new RequiredError('omnimessageId','Required parameter omnimessageId was null or undefined when calling cancelScheduledMessage.');
            }
            const localVarPath = `/omnimessage/{omnimessageId}`
                .replace(`{${"omnimessageId"}}`, encodeURIComponent(String(omnimessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends an Omnimessage.
         * @throws {RequiredError}
         */
        sendOmnimessage(omnimessage: Omnimessage, options: RequestOptions): FetchArgs {
            // verify required parameter 'omnimessage' is not null or undefined
            if (omnimessage === null || omnimessage === undefined) {
                throw new RequiredError('omnimessage','Required parameter omnimessage was null or undefined when calling sendOmnimessage.');
            }
            const localVarPath = `/omnimessage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof omnimessage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(omnimessage || {}) : (((omnimessage:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OmnimessageApiType = { 
    cancelScheduledMessage(omnimessageId: string, options?: RequestOptions): Promise<Response>,

    sendOmnimessage(omnimessage: Omnimessage, options?: RequestOptions): Promise<OmniMessageCreateSuccessResponse>,
}

/**
 * OmnimessageApi - factory function to inject configuration 
 * @export
 */
export const OmnimessageApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OmnimessageApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Cancels a scheduled Omnimessage.
         * @throws {RequiredError}
         */
        cancelScheduledMessage(omnimessageId: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = OmnimessageApiFetchParamCreator(configuration).cancelScheduledMessage(omnimessageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Sends an Omnimessage.
         * @throws {RequiredError}
         */
        sendOmnimessage(omnimessage: Omnimessage, options?: RequestOptions = {}): Promise<OmniMessageCreateSuccessResponse> {
            const localVarFetchArgs = OmnimessageApiFetchParamCreator(configuration).sendOmnimessage(omnimessage, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};

export type ApiTypes = { 
    BlacklistApi: BlacklistApiType,

    ContactsApi: ContactsApiType,

    DeliveryReportApi: DeliveryReportApiType,

    GroupsApi: GroupsApiType,

    OmnimessageApi: OmnimessageApiType,
 }
